# Project 6: The Assembler

In this project, I developed a full-scale **Assembler** for the Hack computer architecture using **Python**. This tool translates symbolic Hack Assembly language (`.asm`) into binary machine code (`.hack`) that can run on the hardware built in previous projects.

## Overview
This project marks the transition from the hardware hierarchy to the software hierarchy. Writing an assembler requires string processing, symbol management, and binary translation logic. I implemented the assembler using a modular object-oriented approach.

## Software Architecture
The project is organized into distinct modules, each handling a specific responsibility of the translation process:

* **`Parser.py`**: Encapsulates access to the input code. It reads the assembly file, removes whitespace/comments, and parses instructions into their underlying fields (A-instruction vs. C-instruction).
* **`Code.py`**: A translation module that converts assembly mnemonics (e.g., `D+1`, `JGT`) into their corresponding binary bits.
* **`SymbolTable.py`**: Manages the symbol table. It handles pre-defined symbols (like `R0`, `SCREEN`), labels (like `(LOOP)`), and user-defined variables (like `@i`).
* **`Main.py`**: The driver program. It orchestrates the process, manages file I/O, and executes the two-pass assembly logic.

## Test Suites & Validation
To ensure accuracy, the repository includes specific test directories (`add`, `max`, `rect`, `pong`, `shift`). Each directory serves as a self-contained test suite containing:
1.  **Source File (`.asm`)**: The input Assembly code.
2.  **Reference File (`.hack`)**: The expected binary output (generated by the official course assembler).

My assembler was validated by running it on the `.asm` source and comparing the resulting output against the reference `.hack` file to ensure a bit-perfect match.

**Included Test Cases:**
* `add/`: Simple arithmetic validation.
* `max/`: Tests conditional jumps and logic.
* `rect/`: Validates symbol handling and screen drawing loops.
* `pong/`: A complex interactive game (approx. 27,000 instructions) used as a stress test for the assembler's robustness.

## Usage
To run the assembler on a specific file:

```bash
# Using the wrapper script
./Assembler path/to/program.asm

# OR running via Python directly
python Main.py path/to/program.asm
